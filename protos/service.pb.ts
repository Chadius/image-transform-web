// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protos/service.proto

import type { ByteSource, ClientConfiguration } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from "twirpscript";

//========================================//
//    ImageTransformer Protobuf Client    //
//========================================//

/**
 * Transform applies the given formula to the image and uses the output settings to return a new image.
 */
export async function Transform(
  dataStreams: DataStreams,
  config?: ClientConfiguration
): Promise<Image> {
  const response = await PBrequest(
    "/chadius.imageTransformServer.ImageTransformer/Transform",
    DataStreams.encode(dataStreams),
    config
  );
  return Image.decode(response);
}

//========================================//
//      ImageTransformer JSON Client      //
//========================================//

/**
 * Transform applies the given formula to the image and uses the output settings to return a new image.
 */
export async function TransformJSON(
  dataStreams: DataStreams,
  config?: ClientConfiguration
): Promise<Image> {
  const response = await JSONrequest<Image>(
    "/chadius.imageTransformServer.ImageTransformer/Transform",
    dataStreams,
    config
  );
  return response;
}

//========================================//
//        ImageTransformer Service        //
//========================================//

/**
 * ImageTransformer Intercepts network calls and uses the creating-symmetry package to transform the given image.
 */
export interface ImageTransformerService<Context = unknown> {
  /**
   * Transform applies the given formula to the image and uses the output settings to return a new image.
   */
  Transform: (
    dataStreams: DataStreams,
    context: Context
  ) => Promise<Image> | Image;
}

export function createImageTransformerHandler<Context>(
  service: ImageTransformerService<Context>
) {
  return {
    name: "chadius.imageTransformServer.ImageTransformer",
    methods: {
      Transform: {
        name: "Transform",
        handler: service.Transform,
        input: DataStreams,
        output: Image,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

/**
 * Raw data byte streams
 */
export interface DataStreams {
  inputImage: Uint8Array;
  formulaData: Uint8Array;
  outputSettings: Uint8Array;
}

/**
 * Raw image data
 */
export interface Image {
  imageData: Uint8Array;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const DataStreams = {
  /**
   * Serializes a DataStreams to protobuf.
   */
  encode: function (dataStreams: Partial<DataStreams>): Uint8Array {
    return DataStreams._writeMessage(
      dataStreams,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a DataStreams from protobuf.
   */
  decode: function (bytes: ByteSource): DataStreams {
    return DataStreams._readMessage(
      DataStreams.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a DataStreams with all fields set to their default value.
   */
  initialize: function (): DataStreams {
    return {
      inputImage: new Uint8Array(),
      formulaData: new Uint8Array(),
      outputSettings: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<DataStreams>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.inputImage) {
      writer.writeBytes(1, msg.inputImage);
    }
    if (msg.formulaData) {
      writer.writeBytes(2, msg.formulaData);
    }
    if (msg.outputSettings) {
      writer.writeBytes(3, msg.outputSettings);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: DataStreams, reader: BinaryReader): DataStreams {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inputImage = reader.readBytes();
          break;
        }
        case 2: {
          msg.formulaData = reader.readBytes();
          break;
        }
        case 3: {
          msg.outputSettings = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Image = {
  /**
   * Serializes a Image to protobuf.
   */
  encode: function (image: Partial<Image>): Uint8Array {
    return Image._writeMessage(image, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Image from protobuf.
   */
  decode: function (bytes: ByteSource): Image {
    return Image._readMessage(Image.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a Image with all fields set to their default value.
   */
  initialize: function (): Image {
    return {
      imageData: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Image>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.imageData) {
      writer.writeBytes(1, msg.imageData);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Image, reader: BinaryReader): Image {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.imageData = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
